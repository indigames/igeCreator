#pragma once

//#include "edgetool/libedgegeomtool.h"
//#include <vector>

#include "pyxieEditableFigure.h"

namespace pyxie {
	///
	/// This file contains structures and functions which can be used as a higher-level wrapper around
	/// the libedgegeomtool API.  This is an "open" wrapper; all functions defined in this file are
	/// implemented in terms of the lower-level public libedgeom API, with no behind-the-scenes magic.
	///

	/// Describes the format of the segment data generated by the tools, and the operations which the
	/// operations which the SPU runtime will be performing on said segments.
	/// The caller is responsible for allocating and freeing all pointer members in this structure.
/*
	struct EdgeGeomSegmentFormat
	{
		// Formats for the main SPU input vertex streams.  The first entry is required to be non-NULL.
		// The second stream is optional (it's useful for instancing certain vertex attributes, or
		// splitting position values into their own stream for a depth-only pass) -- it can be NULL if unused.
		EdgeGeomSpuVertexFormat *m_spuInputVertexFormats[2];
		// Optional blend shape vertex delta stream format.  Must only contain attributes that are present in
		// the SPU input streams, though possibly with different attribute types.  Can be NULL if the scene
		// has no blend shapes.
		EdgeGeomSpuVertexFormat *m_spuInputVertexDeltaFormat;
		// Required SPU output format.  Must only contain attributes that are present in the input streams,
		// though possibly with different attribute types.
		EdgeGeomRsxVertexFormat *m_spuOutputVertexFormat;
		// Optional format for a vertex stream that does not need to be passed through the SPUs for Edge
		// processing, but which needs to be kept in the same order as the Edge attributes (e.g. texture
		// coordinates, lighting coefficients). Can be NULL if all of the scene's attributes must go through the SPU.
		EdgeGeomRsxVertexFormat *m_rsxOnlyVertexFormat;

		EdgeGeomSkinningFlavor m_skinType;
		EdgeGeomCullingFlavor m_cullType; // DEPRECATED -- this field will be removed in a future release.
		EdgeGeomIndexesFlavor m_indexesType;
		EdgeGeomMatrixFormat m_skinMatrixFormat;

		bool m_canBeOccluded; // DEPRECATED -- this field will be removed in a future release.
	};
*/
	/// Provides a convenient container to bundle all the data for a single geometry segment together,
	/// in its final, big-endian form, ready to be written to disk or processed immediately by the SPUs.
	/// The user is responsible for calling edgeGeomFree() on all the data buffers in this structure.
/*
	struct EdgeGeomSegment
	{
		// Copied from the EdgeGeomScene.  Provided only for bookkeeping purposes, so that a mapping
		// can be created from batches to geometry segments.
		uint32_t m_materialId;

		// Filled by edgeGeomMakeSpuConfigInfo
		uint8_t *m_spuConfigInfo;

		// Filled by edgeGeomMakeIndexBuffer
		uint8_t *m_indexes;
		uint16_t m_indexesSizes[2]; // Size of index DMA tags, in bytes.

		// Filled by edgeGeomMakeSpuVertexBuffer
		uint8_t *m_spuVertexes[2]; // One pointer for each input vertex stream (the second stream is optional)
		uint16_t m_spuVertexesSizes[6]; // Sizes of vertex DMA tags, in bytes.  First three sizes are for first input stream, second three for secondary input stream
		uint32_t m_fixedOffsetsSize[2]; // Sizes in bytes. Two sets of offsets, one for each input vertex stream
		uint32_t *m_fixedOffsetPtrs[2]; // Pointers to tables of fixed point offsets, one table per SPU input vertex stream.

		// Filled by edgeGeomMakeRsxVertexBuffer
		uint8_t *m_rsxOnlyVertexes; // Optional vertex stream for this segment that should be sent directly to the RSX.  Can be NULL.
		uint32_t m_rsxOnlyVertexesSize; // Size of m_rsxOnlyVertexes, in bytes.

		// Filled by edgeGeomMake*StreamDescription
		uint8_t *m_spuInputStreamDescriptions[2]; // one stream description each for primary & secondary input vertex streams
		uint16_t m_spuInputStreamDescriptionSizes[2]; // sizes in bytes
		uint8_t *m_spuOutputStreamDescription;
		uint16_t m_spuOutputStreamDescriptionSize; // size in bytes
		uint8_t *m_rsxOnlyStreamDescription; // stream description for the optional RSX-only vertex stream.  Will always be present if m_rsxVertexes is non-NULL.
		uint16_t m_rsxOnlyStreamDescriptionSize; // size in bytes

		// Filled by edgeGeomMakeSkinningBuffers
		uint16_t m_skinMatricesByteOffsets[2]; // Byte offsets of the start of the two matrix ranges to upload with this segment's job data
		uint16_t m_skinMatricesSizes[2]; // size (in bytes) of the two matrix ranges to upload with this segment's job data
		uint8_t *m_skinIndexesAndWeights;
		uint16_t m_skinIndexesAndWeightsSizes[2]; // sizes in bytes of skinning index/weights DMA tags.

		// Comes from the partitioner
		uint32_t m_ioBufferSize; // size in bytes
		// A function of the total input attribute count, the culling flavor, and the number of unique vertexes
		uint32_t m_scratchSize; // in 16-byte qwords

		// Filled by edgeGeomMakeBlendShapeBuffer
		uint32_t m_numBlendShapes;
		uint16_t *m_blendShapeSizes; // size of each blend shape buffer, in bytes.  Has m_numBlendShapes entries.
		uint8_t **m_blendShapes; // array of pointers to blend shape buffers.  Has m_numBlendShapes entries.
	};
*/

	/// Container for the relevant geometry data from the input scene, which will be partitioned into SPU-sized
	/// geometry segments.
	/// The user is responsible for allocating and freeing all pointer members in this structure.
/*
	struct EdgeGeomScene{

		uint32_t nameHash;
		uint32_t materialID;

		uint32_t m_numTriangles;
		uint32_t *m_triangles;

		uint32_t m_numVertexes;
		uint32_t m_numFloatsPerVertex;	//m_numVertexes * m_numFloatsPerVertex = m_vertexes size
		float *m_vertexes;

		uint8_t m_numVertexAttributes;
		uint16_t *m_vertexAttributeIndexes;			//offset of m_vertexes
		EdgeGeomAttributeId *m_vertexAttributeIds;

		int32_t *m_matrixIndexesPerVertex;	//m_numVertexes * 4
		float *m_skinningWeightsPerVertex;	//m_numVertexes * 4

		//---------------------------------------
		bool m_ContinuesIndexes;
		bool skipRender;
		bool useStrip;

		uint32_t m_numTryStrips;
		uint32_t* m_tryStrips;

		uint32_t numTransforms;
		int32_t* m_GPUTransformIndexes;
		uint32_t maxSkinWeightsPerVertex;

		//uint32_t m_numBlendShapes;
		//uint32_t m_numFloatsPerDelta;
		//float *m_vertexDeltas;
		//uint8_t m_numBlendedAttributes;
		//uint16_t *m_blendedAttributeIndexes;
		//EdgeGeomAttributeId *m_blendedAttributeIds;


		EdgeGeomScene()
		{
			materialID = 0;			//
			m_numTriangles=0;		//
			m_triangles=nullptr;	//
			m_numVertexes=0;
			m_numFloatsPerVertex=0;
			m_vertexes= nullptr;
			m_numVertexAttributes=0;
			m_vertexAttributeIndexes=0;
			m_vertexAttributeIds= nullptr;
			//m_numBlendShapes=0;
			//m_numFloatsPerDelta=0;
			//m_vertexDeltas=0;
			//m_numBlendedAttributes=0;
			//m_blendedAttributeIndexes=0;
			//m_blendedAttributeIds=0;

			m_matrixIndexesPerVertex=0;
			m_skinningWeightsPerVertex=0;
			m_GPUTransformIndexes=0;
			m_numTryStrips=0;
			m_tryStrips=0;
			nameHash=0;
			numTransforms=0;
			maxSkinWeightsPerVertex=0;

			m_ContinuesIndexes = false;
			skipRender = false;
			useStrip=true;
		}
	};
*/
	//-------------------

	/// The polygons array should be CCW ordered polygon indexes, terminated with a -1 after each 
	/// polygon.  Terminate the array with an additional -1.  
	/// Each polygon should have a single entry in the materialIdPerPolygon that indicates what 
	/// material it uses.  This is necessary because each triangle generated will also need to know 
	/// what material to use when rendering.
	///
	/// Following example shows two triangles with the same material, followed by a quad with a different material.
	/// polygons:              |a|b|c|-1|a|c|d|-1|a|b|f|g|-1|-1|
	/// materialIdPerPolygon:  |0|0|1|
	void PYXIE_EXPORT edgeGeomTriangulatePolygons(const int32_t *polygons, /*const int32_t *materialIdPerPolygon,*/
		uint32_t **outTriangles, /*int32_t **outMaterialIdPerTriangle,*/ uint32_t *outNumTriangles);

	/// Iterate over the vertexes in an Edge scene, identifying vertexes that are identical to each other.
	/// The actual vertex data is not modified; instead, the triangle list is rewritten to not refer to
	/// duplicate vertexes.
	/// Returns the number of vertexes eliminated due to duplication.
	uint32_t PYXIE_EXPORT edgeGeomMergeIdenticalVertexes(EditableMesh &emash);

	// Performs all end-to-end processing necessary to convert an input scene into a list of geometry segments.
	// This includes:
	// - partitioning the scene into batches (collections of triangles sharing a single material ID and skinning
	//   algorithm)
	// - invoking the Edge partitioner on each batch
	// - creating all necessary output data buffers for each geometry segment
	// - running the kcache optimizer on all partitioner triangle lists, for optimum pre-transform cache performance
	//   on the RSX.
	//void edgeGeomPartitionSceneIntoSegments(const EdgeGeomScene &edgeScene, const EdgeGeomSegmentFormat &edgeFormat,
	//										  EdgeGeomSegment **outSegments, uint32_t *outNumSegments,
	//										  EdgeGeomCustomPartitionDataSizeFunc partitionDataSizeFunc = NULL,
	//										  EdgeGeomCustomCommandBufferHoleSizeFunc commandBufferHoleSizeFunc = NULL);

	// Helper function that simply calls edgeGeomFree() on all of an EdgeGeomSegment's pointer members.
	// It is highly recommended that users use this function instead of manually freeing the structure's members
	// themselves, as this will prevent problems if additional members are added/removed in future releases.
	//void edgeGeomFreeSegmentData(EdgeGeomSegment &segment);
}
